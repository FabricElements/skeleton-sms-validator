<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../paper-input/paper-textarea.html">
<link rel="import" href="../paper-tooltip/paper-tooltip.html">

<dom-module id="skeleton-sms-validator">
  <template>
    <style>
      :host {
        display: block;
      }

      #text-box {
        display: block;
        position: relative;
      }

      paper-textarea[invalid] {
        --paper-input-container-input: {
          outline: var(--paper-red-500);
        }
      }

      #text-box-footer {
        @apply --layout-horizontal;
      }

      #message-type {
        @apply --paper-font-caption;
        background-color: var(--paper-grey-900);
        color: white;
        font-weight: bold;
        border-radius: 5px;
        padding: 0 5px;
      }

      #message-segments {
        @apply --paper-font-caption;
      }

      .char-counter {
        color: var(--paper-indigo-900);
        @apply --paper-font-caption;
      }

      .char-counter[invalid] {
        color: var(--paper-red-500);
      }

      .char-counter p {
        margin: 0;
      }

      .character {
        border-radius: 5px;
        border: 1px solid white;
        color: white;
        display: inline-block;
        font-size: 14px;
        height: 1.5em;
        line-height: 1.5;
        text-align: center;
        vertical-align: top;
        width: 1.5em;
      }

      #message-type.gsm,
      .gsm {
        background-color: var(--paper-grey-900);
      }

      .gsm.double-true {
        background-color: var(--paper-indigo-500);
      }

      #message-type.ucs2,
      .ucs2 {
        background-color: var(--paper-deep-orange-500);
      }

      .divider {
        @apply --layout-flex-auto;
      }
    </style>
    <div id="text-box">
      <paper-textarea label="Message"
                      value="{{text}}"
                      invalid$="[[invalid]]">
      </paper-textarea>
      <div id="text-box-footer">
        <span id="message-type" class$="[[type]]">
          [[type]]
          <paper-tooltip>Message type</paper-tooltip>
        </span>
        <div class="divider"></div>
        <span id="message-segments">
          [[segments]] / [[limitSegments]]
          <paper-tooltip>Segments</paper-tooltip>
        </span>
        <div class="divider"></div>
        <span class="char-counter" invalid$="[[invalid]]">[[charCounter]] / [[_limit]]</span>
      </div>
    </div>
    <div class="message">
      <p class="message-data">
        <template is="dom-repeat" items="[[characters]]">
          <span class$="character [[item.encode]] double-[[item.double]]">
            [[item.text]]
            <paper-tooltip>[[_labelCharacter(item)]]</paper-tooltip>
          </span>
        </template>
      </p>
    </div>
  </template>
  <script src="./encoder-utils.js"></script>
  <script>
    /* eslint-disable max-len */

    /**
     * `skeleton-sms-validator`
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class SkeletonSmsValidator extends Polymer.Element {
      /**
       * @return {string}
       */
      static get is() {
        return 'skeleton-sms-validator';
      }

      /**
       * @return {object}
       */
      static get properties() {
        return {
          type: {
            type: String,
            value: null,
            reflectToAttribute: true,
            notify: true,
          },
          characters: {
            type: Array,
            value: [],
            reflectToAttribute: true,
            notify: true,
          },
          segments: {
            type: Number,
            value: 0,
            reflectToAttribute: true,
            notify: true,
          },
          invalid: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            notify: true,
          },
          text: {
            type: String,
            value: null,
            notify: true,
            reflectToAttribute: true,
            observer: '_textObserver',
          },
          data: {
            type: String,
            value: null,
            reflectToAttribute: true,
            notify: true,
            computed: '_computeData(invalid, text)',
          },
          limitSegments: {
            type: Number,
            value: 2,
          },
          charCounter: {
            type: Array,
            value: [],
            computed: '_computeCharCounter(characters)',
          },
          _limit: {
            type: Number,
            value: 0,
            computed: '_computeLimit(characters, type, limitSegments)',
          },
          labelGsm: {
            type: String,
            value: 'GSM character',
          },
          labelGsmDouble: {
            type: String,
            value: 'GSM character that costs two characters',
          },
          labelUcs2: {
            type: String,
            value: 'Character forces UCS2 encoding',
          },
        };
      }

      /**
       * Observers
       *
       * @return {array}
       */
      static get observers() {
        return [];
      }

      /**
       * Text Observer
       *
       * @param {string} text
       * @private
       */
      _textObserver(text) {
        const baseText = text ? text : '';
        const inputChars = encoderUtils.unicodeCharacters(baseText);

        this.type = encoderUtils.pickencoding(inputChars);

        const baseSegments = this.type === 'gsm'
          ? encoderUtils._segmentWith(160, 153,
            encoderUtils.encodeCharGsm)(inputChars)
          : encoderUtils._segmentWith(140, 134,
            encoderUtils.encodeCharUtf16)(inputChars);
        const segmentBytes = baseSegments[0] && baseSegments[0].bytes ? baseSegments[0].bytes : [];
        this.characters = encoderUtils.unicodeCodePoints(baseText)
          .map((char, index) => {
            const encode = (char in unicodeToGsm) ? 'gsm' : 'ucs2';
            const bytes = segmentBytes[index] ? segmentBytes[index] : 0;
            const isDouble = (encode === 'gsm' && unicodeToGsm[char] && unicodeToGsm[char].length > 1);
            return {
              text: String.fromCodePoint(char),
              encode: encode,
              double: isDouble,
              charBytes: bytes,
              bytes: bytes.reduce((a, b) => a + b, 0),
            };
          });
        this.segments = baseSegments.length;
        this.invalid = baseSegments.length > this.limitSegments;
      }

      /**
       * Segments Observer
       *
       * @param {Array} segments
       * @return {number}
       * @private
       */
      _computeCharCounter(segments) {
        return segments.map((arr) => arr.charBytes.length).reduce((a, b) => a + b, 0);
      }

      /**
       * Messages Observer
       *
       * @param {Array} segments
       * @param {string} type
       * @param {number} limitSegments
       * @return {number}
       * @private
       */
      _computeLimit(segments, type, limitSegments) {
        if (type === 'gsm') {
          if (segments.length <= 1) {
            return 160 * limitSegments;
          } else {
            return 153 * limitSegments;
          }
        }
        if (segments.length <= 1) {
          return 140 * limitSegments;
        } else {
          return 134 * limitSegments;
        }
      }

      /**
       * Compute data
       *
       * @param {boolean} invalid
       * @param {string|null} text
       * @return {string}
       * @private
       */
      _computeData(invalid, text) {
        return invalid ? null : text;
      }

      /**
       * Return label character
       * @param {object} character
       * @return {string}
       * @private
       */
      _labelCharacter(character) {
        let text = 'unknown';
        if (character.encode === 'gsm') {
          text = character.double ? this.labelGsmDouble : this.labelGsm;
        } else if (character.encode === 'ucs2') {
          text = this.labelUcs2;
        }
        return text;
      }
    }

    window.customElements.define(SkeletonSmsValidator.is, SkeletonSmsValidator);
  </script>
</dom-module>
